{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport * as _ from \"lodash\";\nimport * as FileSystem from \"expo-file-system\";\nimport SHA1 from \"crypto-js/sha1\";\nvar BASE_DIR = FileSystem.cacheDirectory + \"expo-image-cache/\";\nexport var CacheEntry = function () {\n  function CacheEntry(uri, options) {\n    _classCallCheck(this, CacheEntry);\n    this.uri = uri;\n    this.options = options;\n  }\n  _createClass(CacheEntry, [{\n    key: \"getPath\",\n    value: function getPath() {\n      var uri, options, _ref, path, exists, tmpPath, result;\n      return _regeneratorRuntime.async(function getPath$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              uri = this.uri, options = this.options;\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(getCacheEntry(uri));\n            case 3:\n              _ref = _context.sent;\n              path = _ref.path;\n              exists = _ref.exists;\n              tmpPath = _ref.tmpPath;\n              if (!exists) {\n                _context.next = 9;\n                break;\n              }\n              return _context.abrupt(\"return\", path);\n            case 9:\n              _context.next = 11;\n              return _regeneratorRuntime.awrap(FileSystem.createDownloadResumable(uri, tmpPath, options).downloadAsync());\n            case 11:\n              result = _context.sent;\n              if (!(result && result.status !== 200)) {\n                _context.next = 14;\n                break;\n              }\n              return _context.abrupt(\"return\", undefined);\n            case 14:\n              _context.next = 16;\n              return _regeneratorRuntime.awrap(FileSystem.moveAsync({\n                from: tmpPath,\n                to: path\n              }));\n            case 16:\n              return _context.abrupt(\"return\", path);\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this);\n    }\n  }]);\n  return CacheEntry;\n}();\nvar CacheManager = function () {\n  function CacheManager() {\n    _classCallCheck(this, CacheManager);\n  }\n  _createClass(CacheManager, null, [{\n    key: \"get\",\n    value: function get(uri, options) {\n      if (!CacheManager.entries[uri]) {\n        CacheManager.entries[uri] = new CacheEntry(uri, options);\n      }\n      return CacheManager.entries[uri];\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      return _regeneratorRuntime.async(function clearCache$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _regeneratorRuntime.awrap(FileSystem.deleteAsync(BASE_DIR, {\n                idempotent: true\n              }));\n            case 2:\n              _context2.next = 4;\n              return _regeneratorRuntime.awrap(FileSystem.makeDirectoryAsync(BASE_DIR));\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      });\n    }\n  }, {\n    key: \"getCacheSize\",\n    value: function getCacheSize() {\n      var result;\n      return _regeneratorRuntime.async(function getCacheSize$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _regeneratorRuntime.awrap(FileSystem.getInfoAsync(BASE_DIR));\n            case 2:\n              result = _context3.sent;\n              if (result.exists) {\n                _context3.next = 5;\n                break;\n              }\n              throw new Error(BASE_DIR + \" not found\");\n            case 5:\n              return _context3.abrupt(\"return\", result.size);\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      });\n    }\n  }]);\n  return CacheManager;\n}();\nCacheManager.entries = {};\nexport { CacheManager as default };\nvar getCacheEntry = function getCacheEntry(uri) {\n  var filename, ext, path, tmpPath, info, exists;\n  return _regeneratorRuntime.async(function getCacheEntry$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          filename = uri.substring(uri.lastIndexOf(\"/\"), uri.indexOf(\"?\") === -1 ? uri.length : uri.indexOf(\"?\"));\n          ext = filename.indexOf(\".\") === -1 ? \".jpg\" : filename.substring(filename.lastIndexOf(\".\"));\n          path = \"\" + BASE_DIR + SHA1(uri) + ext;\n          tmpPath = \"\" + BASE_DIR + SHA1(uri) + \"-\" + _.uniqueId() + ext;\n          _context4.prev = 4;\n          _context4.next = 7;\n          return _regeneratorRuntime.awrap(FileSystem.makeDirectoryAsync(BASE_DIR));\n        case 7:\n          _context4.next = 11;\n          break;\n        case 9:\n          _context4.prev = 9;\n          _context4.t0 = _context4[\"catch\"](4);\n        case 11:\n          _context4.next = 13;\n          return _regeneratorRuntime.awrap(FileSystem.getInfoAsync(path));\n        case 13:\n          info = _context4.sent;\n          exists = info.exists;\n          return _context4.abrupt(\"return\", {\n            exists: exists,\n            path: path,\n            tmpPath: tmpPath\n          });\n        case 16:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[4, 9]]);\n};","map":{"version":3,"mappings":"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","names":["_","FileSystem","SHA1","BASE_DIR","cacheDirectory","CacheEntry","uri","options","_classCallCheck","_createClass","key","value","_context","getCacheEntry","_ref","path","exists","tmpPath","createDownloadResumable","downloadAsync","result","status","undefined","moveAsync","from","to","CacheManager","entries","deleteAsync","idempotent","makeDirectoryAsync","getInfoAsync","Error","size","filename","substring","lastIndexOf","indexOf","length","ext","uniqueId","_context4","info"],"sources":["CacheManager.ts"],"sourcesContent":["// @flow\nimport * as _ from \"lodash\";\nimport * as FileSystem from \"expo-file-system\";\nimport SHA1 from \"crypto-js/sha1\";\n\nexport interface DownloadOptions {\n  md5?: boolean;\n  headers?: { [name: string]: string };\n}\n\nconst BASE_DIR = `${FileSystem.cacheDirectory}expo-image-cache/`;\n\nexport class CacheEntry {\n  uri: string;\n\n  options: DownloadOptions;\n\n  constructor(uri: string, options: DownloadOptions) {\n    this.uri = uri;\n    this.options = options;\n  }\n\n  async getPath(): Promise<string | undefined> {\n    const { uri, options } = this;\n    const { path, exists, tmpPath } = await getCacheEntry(uri);\n    if (exists) {\n      return path;\n    }\n    const result = await FileSystem.createDownloadResumable(uri, tmpPath, options).downloadAsync();\n    // If the image download failed, we don't cache anything\n    if (result && result.status !== 200) {\n      return undefined;\n    }\n    await FileSystem.moveAsync({ from: tmpPath, to: path });\n    return path;\n  }\n}\n\nexport default class CacheManager {\n  static entries: { [uri: string]: CacheEntry } = {};\n\n  static get(uri: string, options: DownloadOptions): CacheEntry {\n    if (!CacheManager.entries[uri]) {\n      CacheManager.entries[uri] = new CacheEntry(uri, options);\n    }\n    return CacheManager.entries[uri];\n  }\n\n  static async clearCache(): Promise<void> {\n    await FileSystem.deleteAsync(BASE_DIR, { idempotent: true });\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  }\n\n  static async getCacheSize(): Promise<number> {\n    const result = await FileSystem.getInfoAsync(BASE_DIR);\n    if (!result.exists) {\n      throw new Error(`${BASE_DIR} not found`);\n    }\n    return result.size;\n  }\n}\n\nconst getCacheEntry = async (uri: string): Promise<{ exists: boolean; path: string; tmpPath: string }> => {\n  const filename = uri.substring(uri.lastIndexOf(\"/\"), uri.indexOf(\"?\") === -1 ? uri.length : uri.indexOf(\"?\"));\n  const ext = filename.indexOf(\".\") === -1 ? \".jpg\" : filename.substring(filename.lastIndexOf(\".\"));\n  const path = `${BASE_DIR}${SHA1(uri)}${ext}`;\n  const tmpPath = `${BASE_DIR}${SHA1(uri)}-${_.uniqueId()}${ext}`;\n  // TODO: maybe we don't have to do this every time\n  try {\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  } catch (e) {\n    // do nothing\n  }\n  const info = await FileSystem.getInfoAsync(path);\n  const { exists } = info;\n  return { exists, path, tmpPath };\n};\n"]},"metadata":{},"sourceType":"module"}